/*
Package migrations manages the state of the Catena database. SQL files should be added
to this directory that implement DDL commands that update the schema of the database
that Catena is connected to. The SQL files are then compiled into the binary using the
catena makemigrations command along with go generate. The catena server and command can
compare the state of the database with its expected state and run any migrations that
are required.
*/
package migrations

//go:generate go run ../cmd/makemigrations

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

// contains all of the available migrations generated by go generate and added in the
// init function of the file migrations.go (the file generated by go generate).
var migrations []Migration

// we will only synchronize the migrations to the database once.
var dbsync sync.Once

// External API

// Num returns the number of migrations in the package
func Num() int {
	return len(migrations)
}

// Migration combines the information about the state of the database and how it has
// been migrated from the migrations table alongside the migration code stored in SQL
// files and compiled into the binary using go generate.
type Migration struct {
	Revision int64     // the unique id of the migration, prefix from the migration file
	Name     string    // the human readable name of the migration, suffix of migration file
	Active   bool      // if the migration has been applied or not
	Applied  time.Time // the timestamp the migration was applied
	Created  time.Time // the timestamp the migration was created in the database
	filename string    // the filename of the associated migration file
	up       string    // the sql query to apply the migration (read from -- migrate: up)
	down     string    // the sql query to rollback the migration (read from -- migrate: down)
	dbsync   bool      // if the migration has been synchronized to the database
}

func (m *Migration) String() string {
	builder := &strings.Builder{}
	fmt.Fprintf(builder, "revision: %d\nname: %q\n", m.Revision, m.Name)
	if m.dbsync {
		fmt.Fprintf(
			builder,
			"active: %t\napplied: %s\ncreated: %s\n",
			m.Active,
			m.Applied.Format("Jan 01, 2006 at 15:04:05 MST"),
			m.Created.Format("Jan 01, 2006 at 15:04:05 MST"),
		)
	}

	fmt.Fprintf(builder, "filename: %s\n", m.filename)

	if m.up != "" {
		fmt.Fprint(builder, "\nup\n--\n")
		fmt.Fprintln(builder, m.up)
	}

	if m.down != "" {
		fmt.Fprint(builder, "\ndown\n----\n")
		fmt.Fprintln(builder, m.down)
	}

	return builder.String()
}

// Filename returns the original filename (before generation)
func (m *Migration) Filename() string {
	return m.filename
}

// UpSQL returns the query that will be executed when Up() is run
func (m *Migration) UpSQL() string {
	return m.up
}

// DownSQL returns the query that will be executed when Down() is run
func (m *Migration) DownSQL() string {
	return m.down
}

// Parse a migration file into an unsynchronized migration struct. This function is only
// used by go generate and though it can help users diagnose migration parsing issues,
// is generally not useful outside of the package.
func Parse(filename string) (m *Migration, err error) {
	m = &Migration{
		filename: filename,
		dbsync:   false,
	}

	if !strings.HasSuffix(filename, ".sql") {
		return nil, errors.New("migration filenames must end in .sql extension")
	}

	parts := strings.Split(strings.TrimSuffix(filename, ".sql"), "_")
	if len(parts) < 2 {
		return nil, errors.New("must format migration filenames as XXXX_description.sql")
	}

	if m.Revision, err = strconv.ParseInt(parts[0], 10, 64); err != nil {
		return nil, fmt.Errorf("could not parse revision from %q: %s", filename, err)
	}

	m.Name = strings.Join(parts[1:], " ")

	upb := &strings.Builder{}
	dnb := &strings.Builder{}

	var (
		f       *os.File
		current *strings.Builder
	)

	if f, err = os.Open(filename); err != nil {
		return nil, fmt.Errorf("could not open %q: %s", filename, err)
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		if strings.HasPrefix(line, "--") {
			line := strings.ToLower(strings.TrimLeft(line, "- \t"))
			if strings.HasPrefix(line, "migrate:") {
				line := strings.TrimLeft(line, "migrate: \t")
				if line == "up" {
					current = upb
				} else if line == "down" {
					current = dnb
				} else {
					return nil, fmt.Errorf("%q is not a valid migrate directive", line)
				}
			}
			continue
		}

		if current == nil {
			return nil, errors.New("did not encounter a 'migrate:' directive")
		}

		current.WriteString(line + " ")
	}

	if err = scanner.Err(); err != nil {
		return nil, err
	}

	m.up = upb.String()
	m.down = dnb.String()

	// append the migration to the migrations
	return m, nil
}

// ByRevision implements sort.Interface for []Migration based on the Revision field.
type ByRevision []Migration

func (a ByRevision) Len() int           { return len(a) }
func (a ByRevision) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByRevision) Less(i, j int) bool { return a[i].Revision < a[j].Revision }

// Internal API

// Add a migration to the local migrations slice, panic if things go wrong.
func local(revision int64, name, filename string, up []byte, down []byte) {
	m := &Migration{
		Revision: revision,
		Name:     name,
		filename: filename,
		dbsync:   false,
	}

	if len(up) > 0 {
		m.up = string(up)
	}

	if len(down) > 0 {
		m.down = string(down)
	}

	if len(migrations) > 0 {
		prev := migrations[len(migrations)-1]
		if m.Revision <= prev.Revision {
			panic(fmt.Errorf("cannot insert revision %d after revision %d", m.Revision, prev.Revision))
		}
	}

	migrations = append(migrations, *m)
}
