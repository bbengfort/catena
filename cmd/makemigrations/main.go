package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bbengfort/catena/migrations"
)

const bindataFile string = "migrations.go"
const bindata string = `package migrations

// Code generated by go generate; DO NOT EDIT.

func init() {
	migrations = make([]Migration, 0, {{ len . }})
	{{- range $i, $m := . }}
	local({{ $m.Revision }}, "{{ $m.Name }}", "{{ $m.Filename }}", []byte{ {{ conv $m.UpSQL }} }, []byte { {{ conv $m.DownSQL }} })
	{{- end }}
}
`

// Define vars for build template
var conv = map[string]interface{}{"conv": fmtByteSlice}
var tmpl = template.Must(template.New("").Funcs(conv).Parse(bindata))

func main() {
	names, err := filepath.Glob("*.sql")
	checkErr(err, "could not list files: %s")

	if len(names) == 0 {
		checkErr(errors.New("no migrations to generate"), "")
	}

	// Parse the migrations from their SQL files
	objs := make([]migrations.Migration, 0, len(names))
	for _, name := range names {
		m, err := migrations.Parse(name)
		checkErr(err, "could not parse %q: %s", name)
		objs = append(objs, *m)
	}

	// Migrations must be sorted, do this during generate
	sort.Sort(migrations.ByRevision(objs))

	// Create the buffer for the generated code
	builder := &bytes.Buffer{}

	// Execute the template
	err = tmpl.Execute(builder, objs)
	checkErr(err, "could not execute template: %s")

	// fmt.Println(builder.String())

	// Format the generated code
	data, err := format.Source(builder.Bytes())
	checkErr(err, "could not format code: %s")

	// Create the generated code file
	f, err := os.Create(bindataFile)
	checkErr(err, "could not create %s: %s", bindataFile)
	defer f.Close()

	_, err = f.Write(data)
	checkErr(err, "could not write data: %s")

	fmt.Printf("wrote %d generated migrations to %s\n", len(objs), bindataFile)
}

func checkErr(err error, msg string, args ...interface{}) {
	if err != nil {
		if msg != "" {
			args = append(args, err)
			fmt.Fprintf(os.Stderr, msg, args...)
		} else {
			fmt.Fprintln(os.Stderr, err.Error())
		}
		os.Exit(1)
	}
}

func fmtByteSlice(s string) string {
	builder := strings.Builder{}
	b := []byte(s)

	for _, v := range b {
		builder.WriteString(fmt.Sprintf("%d,", int(v)))
	}

	return builder.String()
}
