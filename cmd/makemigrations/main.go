// Use with go generate to create database migrations in the migrations folder.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bbengfort/catena"
	"github.com/bbengfort/catena/migrations"
	"github.com/urfave/cli"
)

const bindataFile string = "migrations.go"
const bindata string = `package migrations

// Code generated by go generate; DO NOT EDIT.

func init() {
	migrations = make([]Migration, 0, {{ len . }})
	{{- range $i, $m := . }}
	local({{ $m.Revision }}, "{{ $m.Name }}", "{{ $m.Filename }}", []byte{ {{ conv $m.UpSQL }} }, []byte { {{ conv $m.DownSQL }} })
	{{- end }}
}
`

// Define vars for build template
var conv = map[string]interface{}{"conv": fmtByteSlice}
var tmpl = template.Must(template.New("").Funcs(conv).Parse(bindata))

func main() {
	// Instantiate the CLI application
	app := cli.NewApp()
	app.Name = "makemigrations"
	app.Version = catena.Version
	app.Usage = "generate migrations from SQL files in the migrations folder"
	app.UsageText = "go generate ./..."
	app.Action = makemigrations
	app.Flags = []cli.Flag{
		cli.BoolFlag{
			Name:  "d, debug",
			Usage: "print the generated file and exit",
		},
	}

	app.Run(os.Args)
}

func makemigrations(c *cli.Context) (err error) {
	var names []string
	if names, err = filepath.Glob("*.sql"); err != nil {
		return cli.NewExitError(fmt.Errorf("could not list files: %s", err), 1)
	}

	if len(names) == 0 {
		return cli.NewExitError("no migrations to generate, did you run go generate?", 2)
	}

	// Parse the migrations from their SQL files
	objs := make([]migrations.Migration, 0, len(names))
	for _, name := range names {
		var m *migrations.Migration
		if m, err = migrations.Parse(name); err != nil {
			return cli.NewExitError(fmt.Errorf("could not parse %q: %s", name, err), 1)
		}
		objs = append(objs, *m)
	}

	// Migrations must be sorted, do this during generate
	sort.Sort(migrations.ByRevision(objs))

	// Create the buffer for the generated code
	builder := &bytes.Buffer{}

	// Execute the template
	if err = tmpl.Execute(builder, objs); err != nil {
		return cli.NewExitError(fmt.Errorf("could not execute template: %s", err), 1)
	}

	if c.Bool("debug") {
		fmt.Println(builder.String())
		return nil
	}

	// Format the generated code
	var data []byte
	if data, err = format.Source(builder.Bytes()); err != nil {
		return cli.NewExitError(fmt.Errorf("could not format code: %s", err), 1)
	}

	// Create the generated code file
	var f *os.File
	if f, err = os.Create(bindataFile); err != nil {
		return cli.NewExitError(fmt.Errorf("could not create %s: %s", bindataFile, err), 1)
	}
	defer f.Close()

	if _, err = f.Write(data); err != nil {
		return cli.NewExitError(fmt.Errorf("could not write data: %s", err), 1)
	}

	fmt.Printf("wrote %d generated migrations to %s\n", len(objs), bindataFile)
	return nil
}

func fmtByteSlice(s string) string {
	builder := strings.Builder{}
	b := []byte(s)

	for _, v := range b {
		builder.WriteString(fmt.Sprintf("%d,", int(v)))
	}

	return builder.String()
}
